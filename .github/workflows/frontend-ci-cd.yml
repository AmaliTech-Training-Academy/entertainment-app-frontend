# name: CineVerse Frontend (Production environment)

# env:
#   APP_NAME: 'entertainment-app-frontend'
#   AWS_REGION: 'eu-west-1'
#   TERRAFORM_VERSION: '1.9.8'
#   NODE_VERSION: '18'

# on:
#   push:
#     branches: [dev, staging, prod]
#     paths: ['frontend/**', 'terraform/**', '.github/workflows/frontend-ci-cd.yml']
#   pull_request:
#     branches: [dev, staging, prod]
#     paths: ['frontend/**', 'terraform/**']

# jobs:
#   # =============================================================================
#   # Environment Configuration
#   # =============================================================================
#   setup:
#     name: Setup Environment
#     runs-on: self-hosted
#     outputs:
#       environment: ${{ steps.config.outputs.environment }}
#       should_deploy: ${{ steps.config.outputs.should_deploy }}
#       is_production: ${{ steps.config.outputs.is_production }}
#       requires_approval: ${{ steps.config.outputs.requires_approval }}
#     steps:
#       - name: Configure Environment
#         id: config
#         run: |
#           BRANCH="${{ github.ref_name }}"
#           EVENT_NAME="${{ github.event_name }}"
          
#           echo "Environment Detection:"
#           echo "Branch: $BRANCH"
#           echo "Event: $EVENT_NAME"
          
#           # Set environment based on branch
#           if [[ "$BRANCH" == "prod" ]]; then
#             echo "environment=prod" >> $GITHUB_OUTPUT
#             echo "is_production=true" >> $GITHUB_OUTPUT
#             echo "requires_approval=true" >> $GITHUB_OUTPUT
#             echo "Environment set to: prod (production)"
#             ENV_NAME="prod"
#           elif [[ "$BRANCH" == "staging" ]]; then
#             echo "environment=staging" >> $GITHUB_OUTPUT
#             echo "is_production=false" >> $GITHUB_OUTPUT
#             echo "requires_approval=true" >> $GITHUB_OUTPUT
#             echo "Environment set to: staging"
#             ENV_NAME="staging"
#           else
#             echo "environment=dev" >> $GITHUB_OUTPUT
#             echo "is_production=false" >> $GITHUB_OUTPUT
#             echo "requires_approval=false" >> $GITHUB_OUTPUT
#             echo "Environment set to: dev (default)"
#             ENV_NAME="dev"
#           fi
          
#           # Only deploy on push to main branches
#           if [[ "$EVENT_NAME" == "push" && "$BRANCH" =~ ^(dev|staging|prod)$ ]]; then
#             echo "should_deploy=true" >> $GITHUB_OUTPUT
#             echo "Deployment enabled for push to $BRANCH"
#             SHOULD_DEPLOY="true"
#           else
#             echo "should_deploy=false" >> $GITHUB_OUTPUT
#             echo "Deployment disabled (event: $EVENT_NAME, branch: $BRANCH)"
#             SHOULD_DEPLOY="false"
#           fi
          
#           echo ""
#           echo "Final Configuration:"
#           echo "Environment: $ENV_NAME"
#           echo "Should Deploy: $SHOULD_DEPLOY"
#           echo "Is Production: $([ "$BRANCH" == "prod" ] && echo "true" || echo "false")"
#           echo "Requires Approval: $([ "$BRANCH" == "prod" ] || [ "$BRANCH" == "staging" ] && echo "true" || echo "false")"

#   # =============================================================================
#   # Enhanced Security Scanning
#   # =============================================================================
#   security:
#     name: Security Scan
#     runs-on: self-hosted
#     needs: setup
#     if: always()
#     steps:
#       - uses: actions/checkout@v4
      
#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: ${{ env.NODE_VERSION }}
#           cache: 'npm'
#           cache-dependency-path: frontend/package-lock.json

#       - name: Install Dependencies
#         working-directory: frontend
#         run: npm ci

#       - name: NPM Security Audit
#         working-directory: frontend
#         run: |
#           npm audit --audit-level=moderate --json > npm-audit-report.json || true
#           npm audit --audit-level=moderate
#         continue-on-error: false

#       - name: Terraform Security Scan
#         uses: aquasecurity/tfsec-action@v1.0.0
#         with:
#           working_directory: terraform/
#           format: sarif
#           soft_fail: true

#       - name: Production-Only: Enhanced Security Checks
#         if: needs.setup.outputs.is_production == 'true'
#         working-directory: frontend
#         run: |
#           echo "Running enhanced security checks for production..."
          
#           # Check for console.log statements in production build
#           if grep -r "console\." src/ --exclude-dir=node_modules; then
#             echo "WARNING: console statements found in source code"
#           fi
          
#           # Check for development dependencies in package.json
#           if jq -e '.dependencies | keys[] | select(test("dev|test|mock"))' package.json; then
#             echo "WARNING: Development packages found in dependencies"
#           fi

#       - name: Upload Security Reports
#         uses: actions/upload-artifact@v4
#         if: always()
#         with:
#           name: security-reports-${{ github.sha }}
#           path: |
#             frontend/npm-audit-report.json
#             terraform/tfsec-report.sarif
#           retention-days: 30

#   # =============================================================================
#   # Build and Test
#   # =============================================================================
#   build:
#     name: Build & Test
#     runs-on: self-hosted
#     needs: [setup]
#     if: always()
#     steps:
#       - uses: actions/checkout@v4
      
#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: ${{ env.NODE_VERSION }}
#           cache: 'npm'
#           cache-dependency-path: frontend/package-lock.json

#       - name: Install Dependencies
#         working-directory: frontend
#         run: npm ci

#       # Enhanced testing for production
#       - name: Install Chromium for Headless Tests
#         run: sudo apt-get update && sudo apt-get install -y chromium-browser

#       - name: Run Frontend Tests
#         working-directory: frontend
#         env:
#           CHROME_BIN: /usr/bin/chromium-browser
#         run: |
#           npm test -- --no-watch --browsers=ChromeHeadless --code-coverage
#         continue-on-error: ${{ needs.setup.outputs.is_production != 'true' }}

#       - name: Production-Only: Enhanced Testing
#         if: needs.setup.outputs.is_production == 'true'
#         working-directory: frontend
#         run: |
#           echo "Running enhanced tests for production..."
#           npm run test:ci -- --browsers=ChromeHeadless --code-coverage --watch=false
          
#           # Check code coverage thresholds
#           if [ -f coverage/lcov.info ]; then
#             echo "Code coverage report generated"
#           fi

#       - name: Create Environment Files
#         working-directory: frontend/src/environments
#         run: |
#           ENV="${{ needs.setup.outputs.environment }}"
          
#           # Create base environment file
#           cat > environment.ts << 'EOF'
#           export const environment = {
#             production: false,
#             apiUrl: 'http://localhost:3000/api'
#           };
#           EOF
          
#           # Create environment-specific files with enhanced configurations
#           case "$ENV" in
#             "dev")
#               cat > environment.dev.ts << 'EOF'
#           export const environment = {
#             production: false,
#             apiUrl: 'https://api-dev.cineverse.com/api',
#             enableDebugMode: true,
#             enableAnalytics: false,
#             logLevel: 'debug'
#           };
#           EOF
#               ;;
#             "staging")
#               cat > environment.staging.ts << 'EOF'
#           export const environment = {
#             production: false,
#             apiUrl: 'https://api-staging.cineverse.com/api',
#             enableDebugMode: false,
#             enableAnalytics: true,
#             logLevel: 'warn'
#           };
#           EOF
#               ;;
#             "prod")
#               cat > environment.prod.ts << 'EOF'
#           export const environment = {
#             production: true,
#             apiUrl: 'https://api.cineverse.com/api',
#             enableDebugMode: false,
#             enableAnalytics: true,
#             logLevel: 'error',
#             enablePerformanceMonitoring: true,
#             rumConfig: {
#               applicationId: 'cineverse-prod-rum',
#               identityPoolId: 'us-east-1:rum-identity-pool'
#             }
#           };
#           EOF
#               ;;
#           esac

#       - name: Build Application
#         working-directory: frontend
#         run: |
#           ENV="${{ needs.setup.outputs.environment }}"
#           echo "Building for environment: $ENV"
          
#           case "$ENV" in
#             "dev")     npm run build -- --configuration=development ;;
#             "staging") npm run build -- --configuration=staging ;;
#             "prod")    npm run build -- --configuration=production --optimization --aot --build-optimizer ;;
#             *)         echo "Unknown environment: $ENV" && exit 1 ;;
#           esac
          
#           echo "Build completed successfully"
          
#           # Verify build output
#           if [ -d "dist/${{ env.APP_NAME }}" ]; then
#             echo "Build output found in dist/${{ env.APP_NAME }}"
#             ls -la "dist/${{ env.APP_NAME }}"
            
#             # Production-only: Verify bundle size
#             if [[ "$ENV" == "prod" ]]; then
#               echo "Checking bundle sizes for production..."
#               find "dist/${{ env.APP_NAME }}" -name "*.js" -exec ls -lh {} \; | head -10
#             fi
#           else
#             echo "Build output not found"
#             ls -la dist/
#             exit 1
#           fi

#       - name: Upload Build Artifact
#         uses: actions/upload-artifact@v4
#         with:
#           name: frontend-build-${{ needs.setup.outputs.environment }}
#           path: frontend/dist/${{ env.APP_NAME }}
#           retention-days: 7

#       - name: Upload Test Coverage
#         if: needs.setup.outputs.is_production == 'true'
#         uses: actions/upload-artifact@v4
#         with:
#           name: coverage-report-${{ github.sha }}
#           path: frontend/coverage/
#           retention-days: 30

#   # =============================================================================
#   # Infrastructure Planning
#   # =============================================================================
#   plan:
#     name: Infrastructure Plan
#     runs-on: self-hosted
#     needs: [setup, build, security]
#     if: always() && needs.build.result == 'success' && needs.security.result == 'success'
#     env:
#       ENVIRONMENT: ${{ needs.setup.outputs.environment }}
#     outputs:
#       plan_changes: ${{ steps.plan.outputs.plan_changes }}
#       plan_exitcode: ${{ steps.plan.outputs.plan_exitcode }}
#     steps:
#       - uses: actions/checkout@v4
      
#       - name: Debug Environment
#         run: |
#           echo "Plan Job Environment Debug:"
#           echo "ENVIRONMENT (from env): $ENVIRONMENT"
#           echo "setup.outputs.environment: ${{ needs.setup.outputs.environment }}"
#           echo "github.ref_name: ${{ github.ref_name }}"
#           echo "should_deploy: ${{ needs.setup.outputs.should_deploy }}"
#           echo "is_production: ${{ needs.setup.outputs.is_production }}"
      
#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v3
#         with:
#           terraform_version: ${{ env.TERRAFORM_VERSION }}

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Create Enhanced Environment Configuration
#         working-directory: terraform
#         run: |
#           echo "Creating enhanced configuration for environment: $ENVIRONMENT"
#           mkdir -p environments/$ENVIRONMENT
          
#           # Create backend configuration
#           cat > environments/$ENVIRONMENT/backend.hcl << EOF
#           bucket         = "cineverse-terraform-state-$ENVIRONMENT"
#           key            = "frontend/$ENVIRONMENT/terraform.tfstate"
#           region         = "${{ env.AWS_REGION }}"
#           encrypt        = true
#           dynamodb_table = "cineverse-terraform-locks"
#           EOF
          
#           # Environment-specific configurations
#           case "$ENVIRONMENT" in
#             "dev")
#               WAF_ENABLED="false"
#               DOMAIN_NAME='""'
#               BLOCKED_COUNTRIES='[]'
#               COST_CENTER='"frontend-development"'
#               ;;
#             "staging")
#               WAF_ENABLED="true"
#               DOMAIN_NAME='"staging.cineverse.com"'
#               BLOCKED_COUNTRIES='["CN"]'
#               COST_CENTER='"frontend-staging"'
#               ;;
#             "prod")
#               WAF_ENABLED="true"
#               DOMAIN_NAME='"cineverse.com"'
#               BLOCKED_COUNTRIES='["CN", "RU", "KP"]'
#               COST_CENTER='"frontend-production"'
#               ;;
#           esac
          
#           echo "WAF Enabled: $WAF_ENABLED"
#           echo "Domain Name: $DOMAIN_NAME"
#           echo "Blocked Countries: $BLOCKED_COUNTRIES"
          
#           # Create enhanced terraform variables
#           cat > environments/$ENVIRONMENT/terraform.tfvars << EOF
#           # Basic configuration
#           environment      = "$ENVIRONMENT"
#           project_name     = "cineverse"
#           aws_region       = "${{ env.AWS_REGION }}"
          
#           # Security configuration
#           enable_waf       = $WAF_ENABLED
#           blocked_countries = $BLOCKED_COUNTRIES
          
#           # Monitoring and observability
#           enable_monitoring = true
          
#           # Cost management
#           cost_center = $COST_CENTER
#           owner      = "devops-team"
          
#           # Domain configuration
#           domain_name = $DOMAIN_NAME
          
#           # API endpoint
#           api_endpoint = "https://api-$ENVIRONMENT.cineverse.com"
          
#           # Advanced features (production-specific)
#           enable_drift_detection     = $([ "$ENVIRONMENT" = "prod" ] && echo "true" || echo "false")
#           enable_rollback_automation = $([ "$ENVIRONMENT" = "prod" ] && echo "true" || echo "false")
          
#           # Resource tagging
#           tags = {
#             Environment = "$ENVIRONMENT"
#             Project     = "CineVerse"
#             CostCenter  = $COST_CENTER
#             Owner       = "devops-team"
#             Branch      = "${{ github.ref_name }}"
#             CommitSHA   = "${{ github.sha }}"
#             DeployedBy  = "${{ github.actor }}"
#             Backup      = "$([ "$ENVIRONMENT" = "prod" ] && echo "required" || echo "optional")"
#             Compliance  = "$([ "$ENVIRONMENT" = "prod" ] && echo "required" || echo "optional")"
#           }
#           EOF
          
#           echo "Created terraform.tfvars:"
#           cat environments/$ENVIRONMENT/terraform.tfvars
          
#           echo ""
#           echo "Created backend.hcl:"
#           cat environments/$ENVIRONMENT/backend.hcl

#       - name: Terraform Init & Validate
#         working-directory: terraform
#         run: |
#           echo "Initializing Terraform for environment: $ENVIRONMENT"
          
#           terraform init -backend-config="environments/$ENVIRONMENT/backend.hcl" || {
#             echo "Terraform init failed. Checking S3 bucket and DynamoDB table..."
#             aws s3 ls s3://cineverse-terraform-state-$ENVIRONMENT || echo "S3 bucket cineverse-terraform-state-$ENVIRONMENT not found"
#             aws dynamodb describe-table --table-name cineverse-terraform-locks --region ${{ env.AWS_REGION }} || echo "DynamoDB table cineverse-terraform-locks not found"
#             exit 1
#           }
          
#           terraform validate
          
#           # Show current state summary
#           RESOURCE_COUNT=$(terraform state list 2>/dev/null | wc -l || echo 0)
#           echo "Current state contains $RESOURCE_COUNT resources"
          
#           if [[ $RESOURCE_COUNT -gt 0 ]]; then
#             echo "Current resources in state:"
#             terraform state list | head -10
#             if [[ $RESOURCE_COUNT -gt 10 ]]; then
#               echo "... and $((RESOURCE_COUNT - 10)) more"
#             fi
#           fi

#       - name: Terraform Plan with Enhanced Validation
#         id: plan
#         working-directory: terraform
#         run: |
#           echo "Creating Terraform plan for environment: $ENVIRONMENT"
          
#           # Set environment variables for sensitive data
#           export TF_VAR_slack_webhook_url="${{ secrets.SLACK_WEBHOOK_URL }}"
#           export TF_VAR_notification_emails='["${{ secrets.NOTIFICATION_EMAIL }}"]'
          
#           # Check if state file exists and has resources
#           RESOURCE_COUNT=$(terraform state list 2>/dev/null | wc -l || echo 0)
#           echo "Current state contains $RESOURCE_COUNT resources"
          
#           # Run terraform plan with detailed output
#           terraform plan \
#             -var-file="environments/$ENVIRONMENT/terraform.tfvars" \
#             -out="$ENVIRONMENT.tfplan" \
#             -detailed-exitcode \
#             -lock-timeout=10m
          
#           PLAN_EXIT_CODE=$?
#           echo "plan_exitcode=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          
#           if [[ $RESOURCE_COUNT -eq 0 ]]; then
#             echo "State is empty - forcing plan creation for initial deployment"
#             echo "plan_changes=true" >> $GITHUB_OUTPUT
#           elif [[ $PLAN_EXIT_CODE -eq 0 ]]; then
#             echo "No changes needed - infrastructure is up to date"
#             echo "plan_changes=false" >> $GITHUB_OUTPUT
#           elif [[ $PLAN_EXIT_CODE -eq 1 ]]; then
#             echo "Terraform plan failed"
#             echo "plan_changes=error" >> $GITHUB_OUTPUT
#             exit 1
#           elif [[ $PLAN_EXIT_CODE -eq 2 ]]; then
#             echo "Changes detected - plan created successfully"
#             echo "plan_changes=true" >> $GITHUB_OUTPUT
#           fi
          
#           # Verify plan file exists
#           if [[ -f "$ENVIRONMENT.tfplan" ]]; then
#             echo "Plan file created: $ENVIRONMENT.tfplan"
            
#             # Show plan summary for production
#             if [[ "$ENVIRONMENT" == "prod" ]]; then
#               echo "Production plan summary:"
#               terraform show -no-color "$ENVIRONMENT.tfplan" | head -50
#             fi
#           else
#             echo "WARNING: Plan file $ENVIRONMENT.tfplan not created"
#           fi

#       - name: Upload Terraform Plan
#         uses: actions/upload-artifact@v4
#         if: steps.plan.outputs.plan_changes == 'true'
#         with:
#           name: terraform-plan-${{ env.ENVIRONMENT }}
#           path: terraform/${{ env.ENVIRONMENT }}.tfplan
#           retention-days: 7

#   # =============================================================================
#   # Manual Approval for Production/Staging
#   # =============================================================================
#   approval:
#     name: Deployment Approval
#     runs-on: self-hosted
#     needs: [setup, plan]
#     if: needs.setup.outputs.requires_approval == 'true' && needs.setup.outputs.should_deploy == 'true' && needs.plan.result == 'success'
#     environment: 
#       name: ${{ needs.setup.outputs.environment }}-approval
#       url: https://${{ needs.setup.outputs.environment }}.cineverse.com
#     steps:
#       - name: Manual Approval Required
#         run: |
#           echo " Deployment to ${{ needs.setup.outputs.environment }} requires manual approval"
#           echo " Plan Changes: ${{ needs.plan.outputs.plan_changes }}"
#           echo " Environment: ${{ needs.setup.outputs.environment }}"
#           echo " Branch: ${{ github.ref_name }}"
#           echo " Triggered by: ${{ github.actor }}"
#           echo " Commit: ${{ github.sha }}"
          
#           if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
#             echo "  PRODUCTION DEPLOYMENT - Extra caution required!"
#             echo " Security checks passed: ${{ needs.security.result }}"
#             echo " Build completed: ${{ needs.build.result }}"
#             echo " Infrastructure plan: ${{ needs.plan.result }}"
#           fi

#   # =============================================================================
#   # Deployment with Enhanced Features
#   # =============================================================================
#   deploy:
#     name: Deploy to ${{ needs.setup.outputs.environment }}
#     runs-on: self-hosted
#     needs: [setup, plan, approval]
#     if: |
#       always() && 
#       needs.setup.outputs.should_deploy == 'true' && 
#       needs.plan.result == 'success' && 
#       (needs.setup.outputs.requires_approval == 'false' || needs.approval.result == 'success')
#     environment: ${{ needs.setup.outputs.environment }}
#     env:
#       ENVIRONMENT: ${{ needs.setup.outputs.environment }}
#     steps:
#       - uses: actions/checkout@v4
      
#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v3
#         with:
#           terraform_version: ${{ env.TERRAFORM_VERSION }}

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Send Deployment Start Notification
#         if: needs.setup.outputs.is_production == 'true'
#         run: |
#           # Send Slack notification about deployment start
#           if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
#             curl -X POST -H 'Content-type: application/json' \
#               --data "{\"text\":\" Starting deployment to $ENVIRONMENT\n• Branch: ${{ github.ref_name }}\n• Actor: ${{ github.actor }}\n• Commit: \`${{ github.sha }}\`\"}" \
#               "${{ secrets.SLACK_WEBHOOK_URL }}"
#           fi

#       # ... (rest of the deployment steps similar to previous version but with enhanced monitoring)

#       - name: Enhanced Infrastructure Apply
#         working-directory: terraform
#         run: |
#           echo "=== Applying Infrastructure Changes ==="
          
#           # Recreate configuration
#           mkdir -p environments/$ENVIRONMENT
          
#           # Set environment variables for sensitive data
#           export TF_VAR_slack_webhook_url="${{ secrets.SLACK_WEBHOOK_URL }}"
#           export TF_VAR_notification_emails='["${{ secrets.NOTIFICATION_EMAIL }}"]'
          
#           # Initialize terraform
#           terraform init -backend-config="environments/$ENVIRONMENT/backend.hcl"
          
#           # Apply with enhanced monitoring
#           if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
#             echo " PRODUCTION DEPLOYMENT - Enhanced safety measures enabled"
            
#             # Create backup before deployment
#             aws lambda invoke \
#               --function-name "cineverse-$ENVIRONMENT-rollback-handler" \
#               --payload '{"action": "backup"}' \
#               /tmp/backup-response.json || echo "Backup creation skipped (function may not exist yet)"
#           fi
          
#           # Apply terraform changes
#           terraform apply -auto-approve -var-file="environments/$ENVIRONMENT/terraform.tfvars"
          
#           echo " Infrastructure deployment completed successfully"

#       - name: Get Enhanced Infrastructure Outputs
#         id: outputs
#         working-directory: terraform
#         run: |
#           echo "=== Extracting Infrastructure Outputs ==="
          
#           # Wait for state to stabilize
#           sleep 10
          
#           # Extract outputs with enhanced error handling
#           S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
#           CF_ID=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "")
#           CF_DOMAIN=$(terraform output -raw cloudfront_domain_name 2>/dev/null || echo "")
#           WEBSITE_URL=$(terraform output -raw website_url 2>/dev/null || echo "")
          
#           # Production-specific outputs
#           if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
#             RUM_ID=$(terraform output -raw rum_app_monitor_id 2>/dev/null || echo "")
#             ROLLBACK_LAMBDA=$(terraform output -raw rollback_lambda_arn 2>/dev/null || echo "")
#             echo "rum_app_monitor_id=$RUM_ID" >> $GITHUB_OUTPUT
#             echo "rollback_lambda_arn=$ROLLBACK_LAMBDA" >> $GITHUB_OUTPUT
#           fi
          
#           echo "s3_bucket=$S3_BUCKET" >> $GITHUB_OUTPUT
#           echo "cloudfront_id=$CF_ID" >> $GITHUB_OUTPUT
#           echo "cloudfront_domain=$CF_DOMAIN" >> $GITHUB_OUTPUT
#           echo "website_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          
#           echo " Infrastructure outputs extracted successfully"

#       - name: Download Build Artifact
#         uses: actions/download-artifact@v4
#         with:
#           name: frontend-build-${{ env.ENVIRONMENT }}
#           path: build

#       - name: Enhanced S3 Deployment
#         run: |
#           S3_BUCKET="${{ steps.outputs.outputs.s3_bucket }}"
          
#           echo " Deploying to S3 bucket: $S3_BUCKET"
          
#           # Verify build contents
#           echo " Build contents:"
#           ls -la build/
          
#           # Determine deployment path
#           if [ -d "build/browser" ]; then
#             echo " Angular SSR detected - deploying from browser/ directory"
#             DEPLOY_PATH="build/browser"
#           elif [ -f "build/index.html" ]; then
#             echo " Standard Angular build detected"
#             DEPLOY_PATH="build"
#           else
#             echo " ERROR: Neither build/browser nor build/index.html found!"
#             exit 1
#           fi
          
#           # Production-specific: Create deployment metadata
#           if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
#             cat > "$DEPLOY_PATH/deployment-info.json" << EOF
#           {
#             "version": "${{ github.sha }}",
#             "environment": "$ENVIRONMENT",
#             "deployedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
#             "deployedBy": "${{ github.actor }}",
#             "branch": "${{ github.ref_name }}",
#             "buildNumber": "${{ github.run_number }}"
#           }
#           EOF
#           fi
          
#           # Deploy with optimized cache headers
#           echo " Syncing files to S3..."
          
#           # Static assets with long cache
#           aws s3 sync "$DEPLOY_PATH/" s3://$S3_BUCKET/ --delete \
#             --cache-control "public, max-age=31536000, immutable" \
#             --exclude "*.html" --exclude "*.js" --exclude "*.css" \
#             --exclude "deployment-info.json"
          
#           # Dynamic content with short cache
#           aws s3 sync "$DEPLOY_PATH/" s3://$S3_BUCKET/ --delete \
#             --cache-control "public, max-age=0, must-revalidate" \
#             --include "*.html" --include "*.js" --include "*.css" \
#             --include "deployment-info.json"
          
#           echo " S3 deployment completed successfully"

#       - name: Enhanced CloudFront Cache Invalidation
#         if: success()
#         run: |
#           CLOUDFRONT_ID="${{ steps.outputs.outputs.cloudfront_id }}"
          
#           if [[ -z "$CLOUDFRONT_ID" ]]; then
#             echo " CloudFront ID not available. Skipping invalidation."
#             exit 0
#           fi

#           echo " Invalidating CloudFront distribution: $CLOUDFRONT_ID"

#           INVALIDATION_ID=$(aws cloudfront create-invalidation \
#             --distribution-id "$CLOUDFRONT_ID" \
#             --paths "/*" \
#             --query 'Invalidation.Id' \
#             --output text)

#           echo " Cache invalidation created: $INVALIDATION_ID"
          
#           # For production, wait for invalidation to complete
#           if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
#             echo "⏳ Waiting for cache invalidation to complete..."
#             aws cloudfront wait invalidation-completed \
#               --distribution-id "$CLOUDFRONT_ID" \
#               --id "$INVALIDATION_ID" \
#               --cli-read-timeout 300 || echo " Invalidation wait timed out"
#           fi

#       - name: Enhanced Deployment Verification
#         run: |
#           echo " Verifying deployment..."
          
#           DOMAIN="${{ steps.outputs.outputs.cloudfront_domain }}"
#           WEBSITE_URL="https://$DOMAIN"
          
#           # Wait for propagation
#           sleep 30
          
#           # Basic health check
#           RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" $WEBSITE_URL)
          
#           if [[ "$RESPONSE_CODE" == "200" ]]; then
#             echo " Application is responding correctly (HTTP $RESPONSE_CODE)"
#           else
#             echo " Application returned HTTP $RESPONSE_CODE (may need propagation time)"
#           fi
          
#           # Production-specific verification
#           if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
#             echo " Running production-specific health checks..."
            
#             # Check deployment info endpoint
#             DEPLOYMENT_INFO=$(curl -s "$WEBSITE_URL/deployment-info.json" || echo "")
#             if [[ -n "$DEPLOYMENT_INFO" ]]; then
#               echo " Deployment info: $DEPLOYMENT_INFO"
#             fi
            
#             # Check security headers
#             SECURITY_HEADERS=$(curl -s -I $WEBSITE_URL | grep -E "(X-Content-Type-Options|X-Frame-Options|Strict-Transport-Security)" || echo "")
#             if [[ -n "$SECURITY_HEADERS" ]]; then
#               echo " Security headers verified"
#             fi
#           fi

#       - name: Send Success Notification
#         if: success()
#         run: |
#           WEBSITE_URL="${{ steps.outputs.outputs.website_url }}"
          
#           # Send Slack notification
#           if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
#             curl -X POST -H 'Content-type: application/json' \
#               --data "{
#                 \"text\": \" Deployment to $ENVIRONMENT completed successfully!\",
#                 \"attachments\": [{
#                   \"color\": \"good\",
#                   \"fields\": [
#                     {\"title\": \"Environment\", \"value\": \"$ENVIRONMENT\", \"short\": true},
#                     {\"title\": \"URL\", \"value\": \"$WEBSITE_URL\", \"short\": true},
#                     {\"title\": \"Version\", \"value\": \"${{ github.sha }}\", \"short\": true},
#                     {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true}
#                   ]
#                 }]
#               }" \
#               "${{ secrets.SLACK_WEBHOOK_URL }}"
#           fi
          
#           # Update GitHub status
#           echo " Deployment completed successfully!"

#       - name: Send Failure Notification
#         if: failure()
#         run: |
#           # Send failure notification
#           if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
#             curl -X POST -H 'Content-type: application/json' \
#               --data "{
#                 \"text\": \" Deployment to $ENVIRONMENT failed!\",
#                 \"attachments\": [{
#                   \"color\": \"danger\",
#                   \"fields\": [
#                     {\"title\": \"Environment\", \"value\": \"$ENVIRONMENT\", \"short\": true},
#                     {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
#                     {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
#                     {\"title\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": true}
#                   ]
#                 }]
#               }" \
#               "${{ secrets.SLACK_WEBHOOK_URL }}"
#           fi

#       - name: Enhanced Deployment Summary
#         if: always()
#         run: |
#           cat << EOF >> $GITHUB_STEP_SUMMARY
#           #  Deployment Summary
          
#           **Environment:** $ENVIRONMENT  
#           **Status:** ${{ job.status }}  
#           **Application URL:** ${{ steps.outputs.outputs.website_url }}  
#           **S3 Bucket:** ${{ steps.outputs.outputs.s3_bucket }}  
#           **CloudFront ID:** ${{ steps.outputs.outputs.cloudfront_id }}  
#           **Branch:** ${{ github.ref_name }}  
#           **Commit:** ${{ github.sha }}  
#           **Deployed by:** ${{ github.actor }}  
#           **Requires Approval:** ${{ needs.setup.outputs.requires_approval }}  
#           **Is Production:** ${{ needs.setup.outputs.is_production }}
          
#           ##  Infrastructure Features
#           -  CloudFront CDN with optimized caching
#           -  WAF protection: ${{ needs.setup.outputs.environment != 'dev' && ' Enabled' || ' Disabled' }}
#           -  Real User Monitoring: ${{ needs.setup.outputs.is_production == 'true' && ' Enabled' || ' Disabled' }}
#           -  Cost monitoring: ${{ needs.setup.outputs.is_production == 'true' && ' Enabled' || ' Disabled' }}
#           -  Access logging: ${{ needs.setup.outputs.environment != 'dev' && ' Enabled' || ' Disabled' }}
#           -  Automated rollback: ${{ needs.setup.outputs.is_production == 'true' && ' Enabled' || ' Disabled' }}
          
#           ##  Quick Links
#           -  [Application](${{ steps.outputs.outputs.website_url }})
#           -  [CloudWatch Dashboard](https://eu-west-1.console.aws.amazon.com/cloudwatch/home?region=eu-west-1#dashboards:)
#           -  [Cost Dashboard](https://console.aws.amazon.com/billing/home#/bills)
#           EOF