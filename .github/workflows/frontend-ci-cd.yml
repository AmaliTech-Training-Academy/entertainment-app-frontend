name: CineVerse Frontend CI/CD

env:
  APP_NAME: 'entertainment-app-frontend'
  AWS_REGION: 'eu-west-1'
  TERRAFORM_VERSION: '1.6.0'
  NODE_VERSION: '18'

on:
  push:
    branches: [dev, staging, prod]
    paths: ['frontend/**', 'terraform/**', '.github/workflows/frontend-ci-cd.yml']
  pull_request:
    branches: [dev, staging, prod]
    paths: ['frontend/**', 'terraform/**']

jobs:
  # =============================================================================
  # Environment Configuration
  # =============================================================================
  setup:
    name: Setup Environment
    runs-on: self-hosted
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      should_deploy: ${{ steps.config.outputs.should_deploy }}
      is_production: ${{ steps.config.outputs.is_production }}
    steps:
      - name: Configure Environment
        id: config
        run: |
          BRANCH="${{ github.ref_name }}"
          EVENT_NAME="${{ github.event_name }}"
          
          echo "Environment Detection:"
          echo "Branch: $BRANCH"
          echo "Event: $EVENT_NAME"
          
          # Set environment based on branch
          if [[ "$BRANCH" == "prod" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "is_production=true" >> $GITHUB_OUTPUT
            echo "Environment set to: prod (production)"
            ENV_NAME="prod"
          elif [[ "$BRANCH" == "staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "is_production=false" >> $GITHUB_OUTPUT
            echo "Environment set to: staging"
            ENV_NAME="staging"
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "is_production=false" >> $GITHUB_OUTPUT
            echo "Environment set to: dev (default)"
            ENV_NAME="dev"
          fi
          
          # Only deploy on push to main branches
          if [[ "$EVENT_NAME" == "push" && "$BRANCH" =~ ^(dev|staging|prod)$ ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Deployment enabled for push to $BRANCH"
            SHOULD_DEPLOY="true"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "Deployment disabled (event: $EVENT_NAME, branch: $BRANCH)"
            SHOULD_DEPLOY="false"
          fi
          
          # FIXED: Use variables instead of complex command substitution
          echo ""
          echo "Final Configuration:"
          echo "Environment: $ENV_NAME"
          echo "Should Deploy: $SHOULD_DEPLOY"
          echo "Is Production: $([ "$BRANCH" == "prod" ] && echo "true" || echo "false")"

  # =============================================================================
  # Security Scanning
  # =============================================================================
  security:
    name: Security Scan
    runs-on: self-hosted
    needs: setup
    if: always() && (github.event_name == 'pull_request' || needs.setup.outputs.is_production == 'true')
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Dependencies
        working-directory: frontend
        run: npm ci

      - name: NPM Security Audit
        working-directory: frontend
        run: |
          npm audit --audit-level=moderate --json > npm-audit-report.json || true
          npm audit --audit-level=moderate
        continue-on-error: true

      - name: Terraform Security Scan
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: terraform/
          format: sarif
          soft_fail: true

      - name: Secret Detection
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Upload Security Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports-${{ github.sha }}
          path: frontend/npm-audit-report.json
          retention-days: 30

  # =============================================================================
  # Build and Test
  # =============================================================================
  build:
    name: Build & Test
    runs-on: self-hosted
    needs: [setup]
    if: always()
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Dependencies
        working-directory: frontend
        run: npm ci

      - name: Create Environment Files
        working-directory: frontend/src/environments
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          
          # Create base environment file
          cat > environment.ts << 'EOF'
          export const environment = {
            production: false,
            apiUrl: 'http://localhost:3000/api'
          };
          EOF
          
          # Create environment-specific files
          case "$ENV" in
            "dev")
              cat > environment.dev.ts << 'EOF'
          export const environment = {
            production: false,
            apiUrl: 'https://api-dev.cineverse.com/api'
          };
          EOF
              ;;
            "staging")
              cat > environment.staging.ts << 'EOF'
          export const environment = {
            production: false,
            apiUrl: 'https://api-staging.cineverse.com/api'
          };
          EOF
              ;;
            "prod")
              cat > environment.prod.ts << 'EOF'
          export const environment = {
            production: true,
            apiUrl: 'https://api.cineverse.com/api'
          };
          EOF
              ;;
          esac

      - name: Build Application
        working-directory: frontend
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          echo "Building for environment: $ENV"
          
          case "$ENV" in
            "dev")     npm run build -- --configuration=development ;;
            "staging") npm run build -- --configuration=staging ;;
            "prod")    npm run build -- --configuration=production ;;
            *)         echo "Unknown environment: $ENV" && exit 1 ;;
          esac
          
          echo "Build completed successfully"
          
          # Verify build output
          if [ -d "dist/${{ env.APP_NAME }}" ]; then
            echo "Build output found in dist/${{ env.APP_NAME }}"
            ls -la "dist/${{ env.APP_NAME }}"
          else
            echo "Build output not found"
            ls -la dist/
            exit 1
          fi

      - name: Run Tests
        working-directory: frontend
        run: |
          npm test -- --watch=false --browsers=ChromeHeadless
        continue-on-error: true

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ needs.setup.outputs.environment }}
          path: frontend/dist/${{ env.APP_NAME }}
          retention-days: 7

  # =============================================================================
  # Infrastructure Planning
  # =============================================================================
  plan:
    name: Infrastructure Plan
    runs-on: self-hosted
    needs: [setup, build]
    if: always() && needs.build.result == 'success'
    env:
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Debug Environment
        run: |
          echo "Plan Job Environment Debug:"
          echo "ENVIRONMENT (from env): $ENVIRONMENT"
          echo "setup.outputs.environment: ${{ needs.setup.outputs.environment }}"
          echo "github.ref_name: ${{ github.ref_name }}"
          echo "should_deploy: ${{ needs.setup.outputs.should_deploy }}"
          echo "is_production: ${{ needs.setup.outputs.is_production }}"
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create Environment Configuration
        working-directory: terraform
        run: |
          echo "Creating configuration for environment: $ENVIRONMENT"
          mkdir -p environments/$ENVIRONMENT
          
          # Create backend configuration
          cat > environments/$ENVIRONMENT/backend.hcl << EOF
          bucket         = "cineverse-terraform-state-$ENVIRONMENT"
          key            = "frontend/terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "cineverse-terraform-locks"
          EOF
          
          # Determine WAF setting based on environment
          if [[ "$ENVIRONMENT" == "dev" ]]; then
            WAF_ENABLED="false"
            DOMAIN_NAME='""'
          else
            WAF_ENABLED="true"
            DOMAIN_NAME='"'$ENVIRONMENT'.cineverse.com"'
          fi
          
          echo "WAF Enabled: $WAF_ENABLED"
          echo "Domain Name: $DOMAIN_NAME"
          
          # Create terraform variables
          cat > environments/$ENVIRONMENT/terraform.tfvars << EOF
          environment      = "$ENVIRONMENT"
          project_name     = "cineverse"
          aws_region       = "${{ env.AWS_REGION }}"
          enable_waf       = $WAF_ENABLED
          enable_monitoring = true
          
          # Domain configuration
          domain_name = $DOMAIN_NAME
          
          # API endpoint
          api_endpoint = "https://api-$ENVIRONMENT.cineverse.com"
          
          # Tags
          tags = {
            Environment = "$ENVIRONMENT"
            Project     = "CineVerse"
            ManagedBy   = "Terraform"
            Branch      = "${{ github.ref_name }}"
            CommitSHA   = "${{ github.sha }}"
            DeployedBy  = "${{ github.actor }}"
            DeployedAt  = "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          echo "Created terraform.tfvars:"
          cat environments/$ENVIRONMENT/terraform.tfvars
          
          echo ""
          echo "Created backend.hcl:"
          cat environments/$ENVIRONMENT/backend.hcl

      - name: Terraform Init & Validate
        working-directory: terraform
        run: |
          echo "Initializing Terraform for environment: $ENVIRONMENT"
          
          terraform init -backend-config="environments/$ENVIRONMENT/backend.hcl"
          terraform validate
          
          # Show current state summary
          RESOURCE_COUNT=$(terraform state list 2>/dev/null | wc -l)
          echo "Current state contains $RESOURCE_COUNT resources"
          
          if [[ $RESOURCE_COUNT -gt 0 ]]; then
            echo "Current resources in state:"
            terraform state list | head -10
            if [[ $RESOURCE_COUNT -gt 10 ]]; then
              echo "... and $((RESOURCE_COUNT - 10)) more"
            fi
          fi

      - name: Force Unlock Terraform State
        working-directory: terraform
        run: |
          echo "Checking for existing state locks..."
          
          # Try to force unlock if there's a stuck lock
          if ! terraform plan -var-file="environments/$ENVIRONMENT/terraform.tfvars" -detailed-exitcode >/dev/null 2>&1; then
            echo "State appears to be locked. Attempting to force unlock..."
            
            # Get the lock ID from the error (if any)
            LOCK_ID="9cca48a0-697d-9cdc-48c3-a99d9c0d4cb0"
            
            if [[ -n "$LOCK_ID" ]]; then
              echo "Force unlocking with ID: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" || echo "Force unlock failed or not needed"
            fi
          else
            echo "No state lock detected"
          fi

      - name: Import Existing Resources
        working-directory: terraform
        run: |
          echo "Checking for existing resources to import..."
          echo "Environment: $ENVIRONMENT"
          
          # Function to import if not in state
          import_if_needed() {
            local resource_address="$1"
            local resource_id="$2"
            local resource_name="$3"
            
            if ! terraform state show "$resource_address" >/dev/null 2>&1; then
              echo "Importing $resource_name: $resource_address"
              echo "Resource ID: $resource_id"
              
              if terraform import -var-file="environments/$ENVIRONMENT/terraform.tfvars" "$resource_address" "$resource_id" 2>/dev/null; then
                echo "Successfully imported $resource_name"
              else
                echo "$resource_name not found or already managed - will be created if needed"
              fi
            else
              echo "$resource_name already in state"
            fi
          }
          
          # Try to import existing CloudFront policies
          echo "Looking for CloudFront policies..."
          
          SPA_POLICY_ID=$(aws cloudfront list-cache-policies --type custom --query "CachePolicyList.Items[?Name=='${ENVIRONMENT}-spa-cache-policy'].Id" --output text 2>/dev/null || echo "")
          if [[ -n "$SPA_POLICY_ID" && "$SPA_POLICY_ID" != "None" && "$SPA_POLICY_ID" != "" ]]; then
            echo "Found SPA Cache Policy: $SPA_POLICY_ID"
            import_if_needed "module.cloudfront.aws_cloudfront_cache_policy.spa" "$SPA_POLICY_ID" "SPA Cache Policy"
          else
            echo "SPA Cache Policy not found - will be created"
          fi
          
          STATIC_POLICY_ID=$(aws cloudfront list-cache-policies --type custom --query "CachePolicyList.Items[?Name=='${ENVIRONMENT}-static-assets-cache-policy'].Id" --output text 2>/dev/null || echo "")
          if [[ -n "$STATIC_POLICY_ID" && "$STATIC_POLICY_ID" != "None" && "$STATIC_POLICY_ID" != "" ]]; then
            echo "Found Static Assets Cache Policy: $STATIC_POLICY_ID"
            import_if_needed "module.cloudfront.aws_cloudfront_cache_policy.static_assets" "$STATIC_POLICY_ID" "Static Assets Cache Policy"
          else
            echo "Static Assets Cache Policy not found - will be created"
          fi
          
          ORIGIN_POLICY_ID=$(aws cloudfront list-origin-request-policies --type custom --query "OriginRequestPolicyList.Items[?Name=='${ENVIRONMENT}-s3-origin-request-policy'].Id" --output text 2>/dev/null || echo "")
          if [[ -n "$ORIGIN_POLICY_ID" && "$ORIGIN_POLICY_ID" != "None" && "$ORIGIN_POLICY_ID" != "" ]]; then
            echo "Found Origin Request Policy: $ORIGIN_POLICY_ID"
            import_if_needed "module.cloudfront.aws_cloudfront_origin_request_policy.s3_origin" "$ORIGIN_POLICY_ID" "Origin Request Policy"
          else
            echo "Origin Request Policy not found - will be created"
          fi
          
          HEADERS_POLICY_ID=$(aws cloudfront list-response-headers-policies --type custom --query "ResponseHeadersPolicyList.Items[?Name=='${ENVIRONMENT}-security-headers'].Id" --output text 2>/dev/null || echo "")
          if [[ -n "$HEADERS_POLICY_ID" && "$HEADERS_POLICY_ID" != "None" && "$HEADERS_POLICY_ID" != "" ]]; then
            echo "Found Response Headers Policy: $HEADERS_POLICY_ID"
            import_if_needed "module.cloudfront.aws_cloudfront_response_headers_policy.security" "$HEADERS_POLICY_ID" "Response Headers Policy"
          else
            echo "Response Headers Policy not found - will be created"
          fi
          
          # Try to import existing WAF resources (only if WAF is enabled)
          if [[ "$ENVIRONMENT" != "dev" ]]; then
            echo "Looking for WAF resources (WAF enabled for $ENVIRONMENT)..."
            
            WAF_ID=$(aws wafv2 list-web-acls --scope CLOUDFRONT --region us-east-1 --query "WebACLs[?Name=='cineverse-${ENVIRONMENT}-waf'].Id" --output text 2>/dev/null || echo "")
            if [[ -n "$WAF_ID" && "$WAF_ID" != "None" && "$WAF_ID" != "" ]]; then
              echo "Found WAF Web ACL: $WAF_ID"
              import_if_needed "module.waf[0].aws_wafv2_web_acl.main[0]" "$WAF_ID/CLOUDFRONT/us-east-1" "WAF Web ACL"
            else
              echo "WAF Web ACL not found - will be created"
            fi
            
            # Try to import CloudWatch Log Group
            LOG_GROUP_NAME="/aws/wafv2/cineverse-${ENVIRONMENT}"
            if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP_NAME" --region us-east-1 --query "logGroups[?logGroupName=='$LOG_GROUP_NAME']" --output text >/dev/null 2>&1; then
              echo "Found CloudWatch Log Group: $LOG_GROUP_NAME"
              import_if_needed "module.waf[0].aws_cloudwatch_log_group.waf[0]" "$LOG_GROUP_NAME" "CloudWatch Log Group"
            else
              echo "CloudWatch Log Group not found - will be created"
            fi
          else
            echo "WAF disabled for dev environment - skipping WAF resource import"
          fi
          
          echo "Import process completed!"

      - name: Terraform Plan
        working-directory: terraform
        run: |
          echo "Creating Terraform plan for environment: $ENVIRONMENT"
          
          terraform plan \
            -var-file="environments/$ENVIRONMENT/terraform.tfvars" \
            -out="$ENVIRONMENT.tfplan" \
            -detailed-exitcode
          
          PLAN_EXIT_CODE=$?
          echo "PLAN_EXIT_CODE=$PLAN_EXIT_CODE" >> $GITHUB_ENV
          
          case $PLAN_EXIT_CODE in
            0)
              echo "No changes needed - infrastructure is up to date"
              ;;
            1)
              echo "Terraform plan failed"
              exit 1
              ;;
            2)
              echo "Changes detected - plan created successfully"
              ;;
          esac

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        if: env.PLAN_EXIT_CODE == '2'
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: terraform/${{ env.ENVIRONMENT }}.tfplan
          retention-days: 7

  # =============================================================================
  # Deployment
  # =============================================================================
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: self-hosted
    needs: [setup, plan]
    if: needs.setup.outputs.should_deploy == 'true' && needs.plan.result == 'success'
    environment: ${{ needs.setup.outputs.environment }}
    env:
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Recreate Environment Configuration
        working-directory: terraform
        run: |
          echo "Recreating configuration for environment: $ENVIRONMENT"
          mkdir -p environments/$ENVIRONMENT
          
          # Recreate backend configuration
          cat > environments/$ENVIRONMENT/backend.hcl << EOF
          bucket         = "cineverse-terraform-state-$ENVIRONMENT"
          key            = "frontend/terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "cineverse-terraform-locks"
          EOF
          
          # Determine WAF setting based on environment
          if [[ "$ENVIRONMENT" == "dev" ]]; then
            WAF_ENABLED="false"
            DOMAIN_NAME='""'
          else
            WAF_ENABLED="true"
            DOMAIN_NAME='"'$ENVIRONMENT'.cineverse.com"'
          fi
          
          # Recreate terraform variables
          cat > environments/$ENVIRONMENT/terraform.tfvars << EOF
          environment      = "$ENVIRONMENT"
          project_name     = "cineverse"
          aws_region       = "${{ env.AWS_REGION }}"
          enable_waf       = $WAF_ENABLED
          enable_monitoring = true
          
          # Domain configuration
          domain_name = $DOMAIN_NAME
          
          # API endpoint
          api_endpoint = "https://api-$ENVIRONMENT.cineverse.com"
          
          # Tags
          tags = {
            Environment = "$ENVIRONMENT"
            Project     = "CineVerse"
            ManagedBy   = "Terraform"
            Branch      = "${{ github.ref_name }}"
            CommitSHA   = "${{ github.sha }}"
            DeployedBy  = "${{ github.actor }}"
            DeployedAt  = "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config="environments/$ENVIRONMENT/backend.hcl"

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: terraform/

      - name: Apply Infrastructure Changes
        working-directory: terraform
        run: |
          if [[ -f "$ENVIRONMENT.tfplan" ]]; then
            echo "Applying existing plan"
            terraform apply -auto-approve "$ENVIRONMENT.tfplan"
          else
            echo "Creating and applying new plan"
            terraform apply -auto-approve -var-file="environments/$ENVIRONMENT/terraform.tfvars"
          fi

      - name: Get Infrastructure Outputs
        id: outputs
        working-directory: terraform
        run: |
          {
            echo "s3_bucket=$(terraform output -raw s3_bucket_name)"
            echo "cloudfront_id=$(terraform output -raw cloudfront_distribution_id)"
            echo "cloudfront_domain=$(terraform output -raw cloudfront_domain_name)"
          } >> $GITHUB_OUTPUT

      - name: Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ env.ENVIRONMENT }}
          path: build

      - name: Deploy to S3
        run: |
          S3_BUCKET="${{ steps.outputs.outputs.s3_bucket }}"
          
          echo "Deploying to S3 bucket: $S3_BUCKET"
          
          # Verify build contents
          echo "Build contents:"
          ls -la build/
          
          # Deploy with appropriate cache headers
          aws s3 sync build/ s3://$S3_BUCKET/ --delete \
            --cache-control "public, max-age=31536000" \
            --exclude "*.html" --exclude "*.js" --exclude "*.css"
          
          aws s3 sync build/ s3://$S3_BUCKET/ --delete \
            --cache-control "public, max-age=0, must-revalidate" \
            --include "*.html" --include "*.js" --include "*.css"

      - name: Invalidate CloudFront Cache
        run: |
          CLOUDFRONT_ID="${{ steps.outputs.outputs.cloudfront_id }}"
          echo "Invalidating CloudFront distribution: $CLOUDFRONT_ID"
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id $CLOUDFRONT_ID \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "Cache invalidation created: $INVALIDATION_ID"

      - name: Verify Deployment
        run: |
          echo "Waiting for deployment to propagate..."
          sleep 30
          
          DOMAIN="${{ steps.outputs.outputs.cloudfront_domain }}"
          echo "Testing deployment at: https://$DOMAIN"
          
          RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://$DOMAIN)
          
          if [[ "$RESPONSE_CODE" == "200" ]]; then
            echo "Application is responding correctly (HTTP $RESPONSE_CODE)"
          else
            echo "Application returned HTTP $RESPONSE_CODE (may need propagation time)"
          fi

      - name: Deployment Summary
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          # Deployment Successful
          
          **Environment:** $ENVIRONMENT  
          **Application URL:** https://${{ steps.outputs.outputs.cloudfront_domain }}  
          **S3 Bucket:** ${{ steps.outputs.outputs.s3_bucket }}  
          **CloudFront ID:** ${{ steps.outputs.outputs.cloudfront_id }}  
          **Branch:** ${{ github.ref_name }}  
          **Commit:** ${{ github.sha }}  
          **Deployed by:** ${{ github.actor }}
          
          ## Resources Status
          Using existing CloudFront policies and WAF resources where available  
          All resources managed by Terraform state  
          Infrastructure deployed successfully  
          EOF