# =============================================================================
# CineVerse Frontend CI/CD Pipeline
# =============================================================================
# This workflow provides comprehensive CI/CD for the CineVerse frontend application
# with support for both automated and manual deployments across multiple environments.
#
# Key Features:
# - Multi-environment support (dev, staging, prod)
# - Universal approval system for all trigger types
# - Environment protection rules for production/staging
# - Comprehensive security scanning
# - Infrastructure as Code with Terraform
# - CloudFront CDN with HTTP-compatible ALB backend
# - Enhanced monitoring and notifications
#
# Environments:
# - dev: Development environment with auto-approval
# - staging: Pre-production environment with environment protection
# - prod: Production environment with enhanced protections
# =============================================================================

name: CineVerse Frontend (Production environment)

# =============================================================================
# Environment Variables
# =============================================================================
# Global variables used across all jobs in the workflow
env:
  APP_NAME: 'entertainment-app-frontend'    # Angular application name for build artifacts
  TERRAFORM_VERSION: '1.9.8'               # Terraform version for infrastructure deployment
  NODE_VERSION: '18'                       # Node.js version for frontend build

# =============================================================================
# Workflow Triggers
# =============================================================================
# Define when this workflow should execute
on:
  # Automatic triggers for code changes
  push:
    branches: [dev, staging, prod]          # Only trigger on main environment branches
    paths: ['frontend/**', 'terraform/**', '.github/workflows/frontend-ci-cd.yml']
  
  # Pull request validation (no deployment)
  pull_request:
    branches: [dev, staging, prod]          # Validate changes against main branches
    paths: ['frontend/**', 'terraform/**']
  
  # Manual deployment trigger with approval controls
  # This allows team members to manually deploy with explicit approval
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - 'dev'      # Development environment
          - 'staging'  # Staging environment  
          - 'prod'     # Production environment
      
      approve_deployment:
        description: 'Approve deployment to selected environment?'
        required: true
        default: 'no'          # Default to 'no' for safety
        type: choice
        options:
          - 'no'               # Explicitly deny deployment
          - 'yes'              # Explicitly approve deployment
      
      force_rebuild:
        description: 'Force rebuild even if no changes detected?'
        required: false
        default: false         # Optional flag to clear caches and rebuild
        type: boolean
      
      skip_tests:
        description: 'Skip tests (NOT recommended for production)'
        required: false
        default: false         # Emergency option to skip tests (with warnings)
        type: boolean

jobs:
  # =============================================================================
  # Job 1: Environment Configuration and Setup
  # =============================================================================
  # This job determines the target environment and deployment configuration
  # based on the trigger type (push, PR, or manual dispatch)
  setup:
    name: Setup Environment
    runs-on: self-hosted
    
    # Outputs for downstream jobs to use
    outputs:
      environment: ${{ steps.config.outputs.environment }}                    # Target environment (dev/staging/prod)
      should_deploy: ${{ steps.config.outputs.should_deploy }}              # Whether deployment should proceed
      is_production: ${{ steps.config.outputs.is_production }}              # Whether target is production
      requires_approval: ${{ steps.config.outputs.requires_approval }}      # Whether manual approval is needed
      is_manual_dispatch: ${{ steps.config.outputs.is_manual_dispatch }}    # Whether triggered manually
      manual_approval_received: ${{ steps.config.outputs.manual_approval_received }} # Manual approval status
    
    steps:
      - name: Configure Environment (Enhanced)
        id: config
        run: |
          EVENT_NAME="${{ github.event_name }}"
          echo "Event: $EVENT_NAME"
          
          # =================================================================
          # Handle Manual Workflow Dispatch
          # =================================================================
          # When triggered manually, use inputs to determine environment
          # and validate approval before proceeding
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            echo "is_manual_dispatch=true" >> $GITHUB_OUTPUT
            BRANCH="${{ github.event.inputs.environment }}"
            MANUAL_APPROVAL="${{ github.event.inputs.approve_deployment }}"
            FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
            SKIP_TESTS="${{ github.event.inputs.skip_tests }}"
            
            echo "Manual Workflow Dispatch Detected"
            echo "Target Environment: $BRANCH"
            echo "Deployment Approved: $MANUAL_APPROVAL"
            echo "Force Rebuild: $FORCE_REBUILD"
            echo "Skip Tests: $SKIP_TESTS"
            
            # Validate manual approval - this is our first safety check
            # If user didn't explicitly approve, block the deployment
            if [[ "$MANUAL_APPROVAL" != "yes" ]]; then
              echo "Deployment not approved via manual dispatch"
              echo "manual_approval_received=false" >> $GITHUB_OUTPUT
              echo "should_deploy=false" >> $GITHUB_OUTPUT
            else
              echo "Manual approval received via workflow dispatch"
              echo "manual_approval_received=true" >> $GITHUB_OUTPUT
              echo "should_deploy=true" >> $GITHUB_OUTPUT
            fi
          else
            # =============================================================
            # Handle Automatic Triggers (Push/PR)
            # =============================================================
            # For automatic triggers, use the actual branch name
            echo "is_manual_dispatch=false" >> $GITHUB_OUTPUT
            echo "manual_approval_received=false" >> $GITHUB_OUTPUT
            BRANCH="${{ github.ref_name }}"
            
            # Only deploy on push to main branches (not on PRs)
            # PRs are for validation only and don't trigger deployments
            if [[ "$EVENT_NAME" == "push" && "$BRANCH" =~ ^(dev|staging|prod)$ ]]; then
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "Deployment enabled for push to $BRANCH"
            else
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "Deployment disabled (event: $EVENT_NAME, branch: $BRANCH)"
            fi
          fi
          
          # =================================================================
          # Set Environment Configuration
          # =================================================================
          # Configure environment-specific settings based on target branch
          if [[ "$BRANCH" == "prod" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "is_production=true" >> $GITHUB_OUTPUT
            echo "requires_approval=true" >> $GITHUB_OUTPUT  # Production always requires approval
            ENV_NAME="prod"
          elif [[ "$BRANCH" == "staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "is_production=false" >> $GITHUB_OUTPUT
            echo "requires_approval=true" >> $GITHUB_OUTPUT  # Staging requires approval
            ENV_NAME="staging"
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "is_production=false" >> $GITHUB_OUTPUT
            echo "requires_approval=false" >> $GITHUB_OUTPUT # Dev doesn't require approval
            ENV_NAME="dev"
          fi
          
          # =================================================================
          # Output Final Configuration Summary
          # =================================================================
          echo ""
          echo "Final Configuration:"
          echo "Environment: $ENV_NAME"
          echo "Is Manual Dispatch: $EVENT_NAME == workflow_dispatch"
          echo "Manual Approval Received: ${{ github.event.inputs.approve_deployment == 'yes' }}"
          echo "Should Deploy: $(echo '${{ steps.config.outputs.should_deploy }}')"
          echo "Is Production: $([ "$BRANCH" == "prod" ] && echo "true" || echo "false")"
          echo "Requires Environment Approval: $([ "$BRANCH" == "prod" ] || [ "$BRANCH" == "staging" ] && echo "true" || echo "false")"

  # =============================================================================
  # Job 2: Universal Approval Validation (Runs for All Triggers)
  # =============================================================================
  # This job validates approval for ALL trigger types with different logic:
  # - Manual Dispatch: Check workflow inputs
  # - Push: Auto-approve dev, require environment protection for staging/prod
  # - PR: Validation only (no deployment)
  approval_validation:
    name: Approval Validation
    runs-on: self-hosted
    needs: [setup]
    
    # Always run if setup succeeded (regardless of trigger type)
    if: always() && needs.setup.result == 'success'
    
    # Outputs for downstream jobs
    outputs:
      approval_status: ${{ steps.validate.outputs.approval_status }}
      approval_method: ${{ steps.validate.outputs.approval_method }}
      can_deploy: ${{ steps.validate.outputs.can_deploy }}
    
    steps:
      - name: Debug Trigger Context
        run: |
          echo "=== APPROVAL VALIDATION DEBUG ==="
          echo "Event name: ${{ github.event_name }}"
          echo "Ref name: ${{ github.ref_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Is manual dispatch: ${{ needs.setup.outputs.is_manual_dispatch }}"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Should deploy: ${{ needs.setup.outputs.should_deploy }}"
          echo "Requires approval: ${{ needs.setup.outputs.requires_approval }}"
          echo ""
          echo "=== MANUAL DISPATCH INPUTS (if applicable) ==="
          echo "Input environment: '${{ github.event.inputs.environment }}'"
          echo "Input approval: '${{ github.event.inputs.approve_deployment }}'"
          echo "Force rebuild: '${{ github.event.inputs.force_rebuild }}'"
          echo "Skip tests: '${{ github.event.inputs.skip_tests }}'"
          echo ""
      
      - name: Universal Approval Validation
        id: validate
        run: |
          EVENT_NAME="${{ github.event_name }}"
          ENVIRONMENT="${{ needs.setup.outputs.environment }}"
          IS_MANUAL="${{ needs.setup.outputs.is_manual_dispatch }}"
          SHOULD_DEPLOY="${{ needs.setup.outputs.should_deploy }}"
          
          echo "=== UNIVERSAL APPROVAL VALIDATION ==="
          echo "Trigger: $EVENT_NAME"
          echo "Environment: $ENVIRONMENT"
          echo "Should Deploy: $SHOULD_DEPLOY"
          echo ""
          
          # =================================================================
          # Handle Different Trigger Types
          # =================================================================
          
          case "$EVENT_NAME" in
            # ---------------------------------------------------------
            # Manual Dispatch - Check Workflow Inputs
            # ---------------------------------------------------------
            "workflow_dispatch")
              echo "üîß MANUAL DISPATCH VALIDATION"
              MANUAL_APPROVAL="${{ github.event.inputs.approve_deployment }}"
              
              if [[ "$MANUAL_APPROVAL" == "yes" ]]; then
                echo "‚úÖ Manual approval received via workflow input"
                echo "approval_status=approved" >> $GITHUB_OUTPUT
                echo "approval_method=manual_workflow_input" >> $GITHUB_OUTPUT
                echo "can_deploy=true" >> $GITHUB_OUTPUT
              else
                echo "‚ùå Manual approval NOT received"
                echo "approval_status=denied" >> $GITHUB_OUTPUT
                echo "approval_method=manual_workflow_input" >> $GITHUB_OUTPUT
                echo "can_deploy=false" >> $GITHUB_OUTPUT
                
                echo ""
                echo "DEPLOYMENT BLOCKED"
                echo "Reason: Manual approval not provided in workflow input"
                echo "Action: Re-run workflow and select 'yes' for approval"
                exit 1
              fi
              ;;
            
            # ---------------------------------------------------------
            # Push Event - Auto-approve based on environment
            # ---------------------------------------------------------
            "push")
              echo "üì§ PUSH EVENT VALIDATION"
              
              case "$ENVIRONMENT" in
                "dev")
                  echo "‚úÖ Auto-approving DEV environment push"
                  echo "approval_status=auto_approved" >> $GITHUB_OUTPUT
                  echo "approval_method=auto_dev_environment" >> $GITHUB_OUTPUT
                  echo "can_deploy=true" >> $GITHUB_OUTPUT
                  ;;
                "staging"|"prod")
                  echo "‚ö†Ô∏è  $ENVIRONMENT requires environment protection"
                  echo "approval_status=pending_environment_protection" >> $GITHUB_OUTPUT
                  echo "approval_method=github_environment_protection" >> $GITHUB_OUTPUT
                  echo "can_deploy=true" >> $GITHUB_OUTPUT
                  
                  echo ""
                  echo "ENVIRONMENT PROTECTION REQUIRED"
                  echo "Environment: $ENVIRONMENT"
                  echo "Protection: GitHub Environment approval required"
                  echo "Note: Deployment will wait for environment approval"
                  ;;
                *)
                  echo "‚ùå Unknown environment: $ENVIRONMENT"
                  echo "approval_status=denied" >> $GITHUB_OUTPUT
                  echo "approval_method=unknown_environment" >> $GITHUB_OUTPUT
                  echo "can_deploy=false" >> $GITHUB_OUTPUT
                  exit 1
                  ;;
              esac
              ;;
            
            # ---------------------------------------------------------
            # Pull Request - Validation Only (No Deployment)
            # ---------------------------------------------------------
            "pull_request")
              echo "üîç PULL REQUEST VALIDATION"
              echo "approval_status=validation_only" >> $GITHUB_OUTPUT
              echo "approval_method=pull_request_validation" >> $GITHUB_OUTPUT
              echo "can_deploy=false" >> $GITHUB_OUTPUT
              
              echo ""
              echo "PULL REQUEST VALIDATION MODE"
              echo "Purpose: Code validation and testing only"
              echo "Deployment: Disabled for pull requests"
              echo "Action: Merge PR to trigger deployment"
              ;;
            
            # ---------------------------------------------------------
            # Unknown Trigger Type
            # ---------------------------------------------------------
            *)
              echo "‚ùå Unknown trigger type: $EVENT_NAME"
              echo "approval_status=denied" >> $GITHUB_OUTPUT
              echo "approval_method=unknown_trigger" >> $GITHUB_OUTPUT
              echo "can_deploy=false" >> $GITHUB_OUTPUT
              exit 1
              ;;
          esac
          
          # =================================================================
          # Additional Validation for Production
          # =================================================================
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            echo ""
            echo "üö® PRODUCTION DEPLOYMENT DETECTED"
            echo "Extra validation required for production:"
            echo "   ‚úì Actor: ${{ github.actor }}"
            echo "   ‚úì Trigger: $EVENT_NAME"
            echo "   ‚úì Branch: ${{ github.ref_name }}"
            echo "   ‚úì Time: $(date)"
            
            # For production manual dispatch, add extra warnings
            if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
              echo ""
              echo "‚ö†Ô∏è  PRODUCTION MANUAL DEPLOYMENT"
              echo "Please confirm:"
              echo "   - All tests have passed"
              echo "   - Security scan completed"
              echo "   - Stakeholders notified"
              echo "   - Rollback plan ready"
            fi
          fi
          
          # =================================================================
          # Final Summary
          # =================================================================
          echo ""
          echo "=== APPROVAL VALIDATION SUMMARY ==="
          echo "Status: $(grep 'approval_status=' $GITHUB_OUTPUT | cut -d'=' -f2)"
          echo "Method: $(grep 'approval_method=' $GITHUB_OUTPUT | cut -d'=' -f2)"
          echo "Can Deploy: $(grep 'can_deploy=' $GITHUB_OUTPUT | cut -d'=' -f2)"
      
      - name: Production Safety Check
        if: needs.setup.outputs.is_production == 'true'
        run: |
          echo "üîí PRODUCTION SAFETY CHECK"
          echo ""
          echo "This is a PRODUCTION deployment!"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Approval Method: ${{ steps.validate.outputs.approval_method }}"
          echo ""
          
          # Additional production-specific validations
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.skip_tests }}" == "true" ]]; then
              echo "‚ö†Ô∏è  WARNING: Tests are being skipped for PRODUCTION!"
              echo "This is NOT recommended for production deployments."
            fi
          fi
          
          echo "‚úì Production safety check completed"

  # =============================================================================
  # Job 3: Security Scanning and Vulnerability Assessment
  # =============================================================================
  # Comprehensive security scanning for both application code and infrastructure
  # This job must pass before deployment can proceed
  security:
    name: Security Scan
    runs-on: self-hosted
    needs: [setup, approval_validation]
    
    # Run if setup succeeded and approval validation passed
    if: |
      always() && 
      needs.setup.result == 'success' &&
      needs.approval_validation.result == 'success'
    
    steps:
      # Checkout code for security scanning
      - uses: actions/checkout@v4
      
      # =================================================================
      # Setup Node.js Environment
      # =================================================================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'                                    # Enable npm caching for faster builds
          cache-dependency-path: frontend/package-lock.json

      # =================================================================
      # Install Dependencies for Security Scanning
      # =================================================================
      - name: Install Dependencies
        working-directory: frontend
        run: npm ci  # Use 'ci' for faster, reproducible installs in CI environment

      # =================================================================
      # NPM Security Audit
      # =================================================================
      # Check for known vulnerabilities in dependencies
      - name: NPM Security Audit
        working-directory: frontend
        run: |
          # Generate JSON report for artifact storage
          npm audit --audit-level=moderate --json > npm-audit-report.json || true
          
          # Run audit with console output (fails on moderate+ vulnerabilities)
          npm audit --audit-level=moderate
        continue-on-error: false  # Fail the build if vulnerabilities are found

      # =================================================================
      # Terraform Security Scanning
      # =================================================================
      # Scan Terraform code for security misconfigurations
      - name: Terraform Security Scan
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: terraform/
          format: sarif                   # Generate SARIF format for GitHub integration
          soft_fail: true                 # Don't fail build, but report issues

      # =================================================================
      # Production-Specific Security Checks
      # =================================================================
      # Additional security validation for production deployments
      - name: Production-Only Enhanced Security Checks
        if: needs.setup.outputs.is_production == 'true'
        working-directory: frontend
        run: |
          echo "Running enhanced security checks for production..."
          
          # Check for console.log statements that might leak sensitive info
          if grep -r "console\." src/ --exclude-dir=node_modules; then
            echo "WARNING: console statements found in source code"
          fi
          
          # Check for development dependencies in production package.json
          if jq -e '.dependencies | keys[] | select(test("dev|test|mock"))' package.json; then
            echo "WARNING: Development packages found in dependencies"
          fi

      # =================================================================
      # Upload Security Reports for Review
      # =================================================================
      - name: Upload Security Reports
        uses: actions/upload-artifact@v4
        if: always()  # Always upload, even if security checks fail
        with:
          name: security-reports-${{ github.sha }}
          path: |
            frontend/npm-audit-report.json
            terraform/tfsec-report.sarif
          retention-days: 30

  # =============================================================================
  # Job 4: Build and Test Application
  # =============================================================================
  # Build the frontend application and run comprehensive tests
  # Supports both manual dispatch options and environment-specific builds
  build:
    name: Build & Test
    runs-on: self-hosted
    needs: [setup, approval_validation]
    
    # Run if setup succeeded and approval validation passed
    if: |
      always() && 
      needs.setup.result == 'success' &&
      needs.approval_validation.result == 'success'
    
    steps:
      # Checkout source code
      - uses: actions/checkout@v4
      
      # =================================================================
      # Setup Node.js Build Environment
      # =================================================================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      # =================================================================
      # Install Project Dependencies
      # =================================================================
      - name: Install Dependencies
        working-directory: frontend
        run: npm ci  # Clean install for reproducible builds

      # =================================================================
      # Build Application for Target Environment
      # =================================================================
      # Build the application with environment-specific configurations
      - name: Build Application
        working-directory: frontend
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          echo "Building for environment: $ENV"
          
          # Check if force rebuild is enabled (clears caches)
          if [[ "${{ github.event.inputs.force_rebuild }}" == "true" ]]; then
            echo "Force rebuild enabled - cleaning build cache"
            rm -rf dist/ node_modules/.cache/ || true
          fi
          
          # Environment-specific build configurations
          case "$ENV" in
            "dev")     
              # Development build with source maps and debugging
              npm run build -- --configuration=development ;;
            "staging") 
              # Staging build with production optimizations but debugging enabled
              npm run build -- --configuration=staging ;;
            "prod")    
              # Full production build with all optimizations
              npm run build -- --configuration=production ;;
            *)         
              echo "Unknown environment: $ENV" && exit 1 ;;
          esac
          
          echo "Build completed successfully"
          
          # =============================================================
          # Verify Build Output
          # =============================================================
          if [ -d "dist/${{ env.APP_NAME }}" ]; then
            echo "Build output found in dist/${{ env.APP_NAME }}"
            ls -la "dist/${{ env.APP_NAME }}"
            
            # Production-specific bundle size analysis
            if [[ "$ENV" == "prod" ]]; then
              echo "Checking bundle sizes for production..."
              find "dist/${{ env.APP_NAME }}" -name "*.js" -exec ls -lh {} \; | head -10
            fi
          else
            echo "Build output not found"
            ls -la dist/
            exit 1
          fi

      # =================================================================
      # Upload Build Artifacts
      # =================================================================
      # Store build artifacts for deployment job
      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ needs.setup.outputs.environment }}
          path: frontend/dist/${{ env.APP_NAME }}
          retention-days: 7

      # =================================================================
      # Upload Test Coverage (Production Only)
      # =================================================================
      # Store coverage reports for production builds
      - name: Upload Test Coverage
        if: needs.setup.outputs.is_production == 'true' && github.event.inputs.skip_tests != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ github.sha }}
          path: frontend/coverage/
          retention-days: 30

  # =============================================================================
  # Job 5: Infrastructure Planning with Terraform
  # =============================================================================
  # Plan infrastructure changes using Terraform
  # Creates execution plans that will be applied during deployment
  plan:
    name: Infrastructure Plan
    runs-on: self-hosted
    needs: [setup, build, security, approval_validation]
    
    # Only run if build and security jobs completed successfully AND approval passed
    if: |
      always() && 
      needs.build.result == 'success' && 
      needs.security.result == 'success' &&
      needs.approval_validation.outputs.can_deploy == 'true'
    
    env:
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
    
    # Outputs for deployment job
    outputs:
      plan_changes: ${{ steps.plan.outputs.plan_changes }}      # Whether infrastructure changes are needed
      plan_exitcode: ${{ steps.plan.outputs.plan_exitcode }}   # Terraform plan exit code
    
    steps:
      # Checkout source code for Terraform files
      - uses: actions/checkout@v4
      
      # =================================================================
      # Debug Environment Configuration
      # =================================================================
      - name: Debug Environment
        run: |
          echo "Plan Job Environment Debug:"
          echo "ENVIRONMENT (from env): $ENVIRONMENT"
          echo "setup.outputs.environment: ${{ needs.setup.outputs.environment }}"
          echo "github.ref_name: ${{ github.ref_name }}"
          echo "should_deploy: ${{ needs.setup.outputs.should_deploy }}"
          echo "is_production: ${{ needs.setup.outputs.is_production }}"
          echo "is_manual_dispatch: ${{ needs.setup.outputs.is_manual_dispatch }}"
          echo "approval_status: ${{ needs.approval_validation.outputs.approval_status }}"
          echo "can_deploy: ${{ needs.approval_validation.outputs.can_deploy }}"
      
      # =================================================================
      # Setup Terraform
      # =================================================================
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # =================================================================
      # Configure AWS Credentials
      # =================================================================
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # =================================================================
      # Create Environment-Specific Configuration
      # =================================================================
      # Generate Terraform variables and backend configuration for each environment
      - name: Create Enhanced Environment Configuration
        working-directory: terraform
        run: |
          echo "Creating enhanced configuration for environment: $ENVIRONMENT"
          mkdir -p environments/$ENVIRONMENT
          
          # =============================================================
          # Create Terraform Backend Configuration
          # =============================================================
          # Each environment uses its own state file for isolation
          cat > environments/$ENVIRONMENT/backend.hcl << EOF
          bucket         = "cineverse-terraform-state-$ENVIRONMENT"
          key            = "frontend/$ENVIRONMENT/terraform.tfstate"
          region         = "${{ secrets.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "cineverse-terraform-locks"
          EOF
          
          # =============================================================
          # Environment-Specific Configuration
          # =============================================================
          # Set different security and infrastructure settings per environment
          case "$ENVIRONMENT" in
            "dev")
              WAF_ENABLED="false"                                                              # No WAF for dev
              DOMAIN_NAME='""'                                                                 # No custom domain
              BLOCKED_COUNTRIES='[]'                                                           # No geo-blocking
              COST_CENTER='"frontend-development"'                                            # Cost tracking
              ALB_DOMAIN="cineverse-service-alb-staging-276074081.eu-west-1.elb.amazonaws.com" # Dev ALB
              ;;
            "staging")
              WAF_ENABLED="true"                                                               # Enable WAF
              DOMAIN_NAME='"staging.cineverse.com"'                                           # Staging domain
              BLOCKED_COUNTRIES='["CN"]'                                                       # Basic geo-blocking
              COST_CENTER='"frontend-staging"'                                                # Cost tracking
              ALB_DOMAIN="cineverse-service-alb-staging-276074081.eu-west-1.elb.amazonaws.com" # Staging ALB
              ;;
            "prod")
              WAF_ENABLED="true"                                                               # Enable WAF
              DOMAIN_NAME='"cineverse.com"'                                                    # Production domain
              BLOCKED_COUNTRIES='["CN", "RU", "KP"]'                                          # Enhanced geo-blocking
              COST_CENTER='"frontend-production"'                                             # Cost tracking
              ALB_DOMAIN="cineverse-prod-service-alb-964667856.eu-west-1.elb.amazonaws.com"   # Production ALB
              ;;
          esac
          
          echo "WAF Enabled: $WAF_ENABLED"
          echo "Domain Name: $DOMAIN_NAME"
          echo "Blocked Countries: $BLOCKED_COUNTRIES"
          echo "ALB Domain: $ALB_DOMAIN"
          
          # =============================================================
          # Create Terraform Variables File
          # =============================================================
          cat > environments/$ENVIRONMENT/terraform.tfvars << EOF
          # Basic configuration
          environment      = "$ENVIRONMENT"
          project_name     = "cineverse"
          aws_region       = "${{ secrets.AWS_REGION }}"
          
          # Security configuration
          enable_waf       = $WAF_ENABLED
          blocked_countries = $BLOCKED_COUNTRIES
          
          # Monitoring and observability
          enable_monitoring = true
          
          # Cost management
          cost_center = $COST_CENTER
          owner      = "devops-team"
          
          # Domain configuration
          domain_name = $DOMAIN_NAME
          
          # ALB domain for HTTP communication (CRITICAL for CloudFront-ALB integration)
          alb_domain_name = "$ALB_DOMAIN"
          
          # API endpoint (for backward compatibility)
          api_endpoint = "http://$ALB_DOMAIN"
          
          # Advanced features (production-specific)
          enable_drift_detection     = $([ "$ENVIRONMENT" = "prod" ] && echo "true" || echo "false")
          enable_rollback_automation = $([ "$ENVIRONMENT" = "prod" ] && echo "true" || echo "false")
          
          # Resource tagging for governance and cost tracking
          tags = {
            Environment = "$ENVIRONMENT"
            Project     = "CineVerse"
            CostCenter  = $COST_CENTER
            Owner       = "devops-team"
            Branch      = "${{ github.ref_name }}"
            CommitSHA   = "${{ github.sha }}"
            DeployedBy  = "${{ github.actor }}"
            DeployMethod = "${{ needs.setup.outputs.is_manual_dispatch == 'true' && 'Manual Dispatch' || 'Automated' }}"
            Backup      = "$([ "$ENVIRONMENT" = "prod" ] && echo "required" || echo "optional")"
            Compliance  = "$([ "$ENVIRONMENT" = "prod" ] && echo "required" || echo "optional")"
          }
          EOF
          
          echo "Created terraform.tfvars:"
          cat environments/$ENVIRONMENT/terraform.tfvars
          
          echo ""
          echo "Created backend.hcl:"
          cat environments/$ENVIRONMENT/backend.hcl

      # =================================================================
      # Initialize and Validate Terraform
      # =================================================================
      - name: Terraform Init & Validate
        working-directory: terraform
        run: |
          echo "Initializing Terraform for environment: $ENVIRONMENT"
          
          # Initialize Terraform with environment-specific backend
          terraform init -backend-config="environments/$ENVIRONMENT/backend.hcl" || {
            echo "Terraform init failed. Checking S3 bucket and DynamoDB table..."
            aws s3 ls s3://cineverse-terraform-state-$ENVIRONMENT || echo "S3 bucket cineverse-terraform-state-$ENVIRONMENT not found"
            aws dynamodb describe-table --table-name cineverse-terraform-locks --region ${{ secrets.AWS_REGION }} || echo "DynamoDB table cineverse-terraform-locks not found"
            exit 1
          }
          
          # Validate Terraform configuration syntax
          terraform validate
          
          # =============================================================
          # Show Current State Summary
          # =============================================================
          RESOURCE_COUNT=$(terraform state list 2>/dev/null | wc -l || echo 0)
          echo "Current state contains $RESOURCE_COUNT resources"
          
          if [[ $RESOURCE_COUNT -gt 0 ]]; then
            echo "Current resources in state:"
            terraform state list | head -10
            if [[ $RESOURCE_COUNT -gt 10 ]]; then
              echo "... and $((RESOURCE_COUNT - 10)) more"
            fi
          fi

      # =================================================================
      # Create Terraform Execution Plan
      # =================================================================
      - name: Terraform Plan with Enhanced Validation
        id: plan
        working-directory: terraform
        run: |
          echo "Creating Terraform plan for environment: $ENVIRONMENT"
          
          # Set environment variables for sensitive data
          export TF_VAR_slack_webhook_url="${{ secrets.SLACK_WEBHOOK_URL }}"
          export TF_VAR_notification_emails='["${{ secrets.NOTIFICATION_EMAIL }}"]'
          
          # Check current state
          RESOURCE_COUNT=$(terraform state list 2>/dev/null | wc -l || echo 0)
          echo "Current state contains $RESOURCE_COUNT resources"
          
          # =============================================================
          # Run Terraform Plan
          # =============================================================
          # -detailed-exitcode: 0=no changes, 1=error, 2=changes detected
          terraform plan \
            -var-file="environments/$ENVIRONMENT/terraform.tfvars" \
            -out="$ENVIRONMENT.tfplan" \
            -detailed-exitcode \
            -lock-timeout=10m
          
          PLAN_EXIT_CODE=$?
          echo "plan_exitcode=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          
          # =============================================================
          # Interpret Plan Results
          # =============================================================
          if [[ $RESOURCE_COUNT -eq 0 ]]; then
            echo "State is empty - forcing plan creation for initial deployment"
            echo "plan_changes=true" >> $GITHUB_OUTPUT
          elif [[ $PLAN_EXIT_CODE -eq 0 ]]; then
            echo "No changes needed - infrastructure is up to date"
            echo "plan_changes=false" >> $GITHUB_OUTPUT
          elif [[ $PLAN_EXIT_CODE -eq 1 ]]; then
            echo "Terraform plan failed"
            echo "plan_changes=error" >> $GITHUB_OUTPUT
            exit 1
          elif [[ $PLAN_EXIT_CODE -eq 2 ]]; then
            echo "Changes detected - plan created successfully"
            echo "plan_changes=true" >> $GITHUB_OUTPUT
          fi
          
          # =============================================================
          # Verify and Display Plan
          # =============================================================
          if [[ -f "$ENVIRONMENT.tfplan" ]]; then
            echo "Plan file created: $ENVIRONMENT.tfplan"
            
            # Show plan summary for production (security review)
            if [[ "$ENVIRONMENT" == "prod" ]]; then
              echo "Production plan summary:"
              terraform show -no-color "$ENVIRONMENT.tfplan" | head -50
            fi
          else
            echo "WARNING: Plan file $ENVIRONMENT.tfplan not created"
          fi

      # =================================================================
      # Upload Terraform Plan for Deployment
      # =================================================================
      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        if: steps.plan.outputs.plan_changes == 'true'
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: terraform/${{ env.ENVIRONMENT }}.tfplan
          retention-days: 7

  # =============================================================================
  # Job 6: Environment Protection Approval
  # =============================================================================
  # This job handles GitHub Environment protection rules for staging/production
  # It only runs when environment protection is needed (not for manual approval or dev)
  environment_approval:
    name: Environment Protection
    runs-on: self-hosted
    needs: [setup, plan, approval_validation]
    
    # Run this job only when:
    # - Environment requires GitHub environment protection (staging/prod)
    # - Deployment should proceed
    # - Infrastructure planning succeeded
    # - Universal approval indicates environment protection is needed
    if: |
      needs.setup.outputs.requires_approval == 'true' && 
      needs.setup.outputs.should_deploy == 'true' && 
      needs.plan.result == 'success' &&
      needs.approval_validation.outputs.approval_method == 'github_environment_protection'
    
    # Use GitHub Environment protection rules
    environment: 
      name: ${{ needs.setup.outputs.environment }}-approval
      url: https://${{ needs.setup.outputs.environment }}.cineverse.com
    
    steps:
      - name: Environment Protection Required
        run: |
          echo "üõ°Ô∏è  ENVIRONMENT PROTECTION APPROVAL"
          echo ""
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Approval Method: ${{ needs.approval_validation.outputs.approval_method }}"
          echo "Universal Approval Status: ${{ needs.approval_validation.outputs.approval_status }}"
          echo ""
          echo "This deployment requires GitHub Environment protection approval."
          echo "Please review the deployment details and approve if ready to proceed."
          
          # Extra warnings for production deployments
          if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
            echo ""
            echo "üö® PRODUCTION DEPLOYMENT - Extra caution required!"
            echo "   Security checks: ${{ needs.security.result }}"
            echo "   Build completed: ${{ needs.build.result }}"
            echo "   Infrastructure plan: ${{ needs.plan.result }}"
            echo ""
            echo "Please review all checks before approving"
          fi

  # =============================================================================
  # Job 7: Deployment Execution
  # =============================================================================
  # This job deploys the application to the target environment
  # It handles both infrastructure deployment and application deployment
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: self-hosted
    needs: [setup, plan, approval_validation, environment_approval]
    
    # Deploy when:
    # - Deployment is approved via universal validation
    # - Infrastructure planning succeeded
    # - Either no environment approval required, OR environment approval received
    if: |
      always() && 
      needs.setup.outputs.should_deploy == 'true' && 
      needs.plan.result == 'success' && 
      needs.approval_validation.outputs.can_deploy == 'true' &&
      (
        needs.setup.outputs.requires_approval == 'false' || 
        needs.environment_approval.result == 'success' ||
        needs.approval_validation.outputs.approval_method == 'manual_workflow_input' ||
        needs.approval_validation.outputs.approval_method == 'auto_dev_environment'
      )
    
    # Use GitHub Environment for deployment tracking
    environment: ${{ needs.setup.outputs.environment }}
    
    env:
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
    
    steps:
      # Checkout source code for deployment
      - uses: actions/checkout@v4
      
      # =================================================================
      # Pre-deployment Summary and Validation
      # =================================================================
      - name: Pre-deployment Summary
        run: |
          echo "üöÄ DEPLOYMENT SUMMARY"
          echo ""
          echo "Environment: $ENVIRONMENT"
          echo "Trigger: ${{ github.event_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "=== APPROVAL CHAIN ==="
          echo "Universal Approval: ${{ needs.approval_validation.outputs.approval_status }}"
          echo "Approval Method: ${{ needs.approval_validation.outputs.approval_method }}"
          echo "Can Deploy: ${{ needs.approval_validation.outputs.can_deploy }}"
          echo "Environment Approval: ${{ needs.environment_approval.result || 'Not Required' }}"
          echo "Manual Dispatch: ${{ needs.setup.outputs.is_manual_dispatch }}"
          echo "Manual Approval: ${{ needs.setup.outputs.manual_approval_received }}"
          echo "Force Rebuild: ${{ github.event.inputs.force_rebuild }}"
          echo "Skip Tests: ${{ github.event.inputs.skip_tests }}"
          echo ""
      
      # =================================================================
      # Setup Deployment Tools
      # =================================================================
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # =================================================================
      # Send Deployment Start Notification (Production Only)
      # =================================================================
      - name: Send Deployment Start Notification
        if: needs.setup.outputs.is_production == 'true'
        run: |
          # Determine deployment method for notification
          if [[ "${{ needs.setup.outputs.is_manual_dispatch }}" == "true" ]]; then
            DEPLOY_METHOD="Manual Dispatch"
            APPROVAL_METHOD="Workflow Input"
          else
            DEPLOY_METHOD="Automated Push"
            APPROVAL_METHOD="Environment Protection"
          fi
          
          # Send Slack notification about deployment start
          if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"Starting deployment to $ENVIRONMENT\",
                \"attachments\": [{
                  \"color\": \"warning\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"$ENVIRONMENT\", \"short\": true},
                    {\"title\": \"Method\", \"value\": \"$DEPLOY_METHOD\", \"short\": true},
                    {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                    {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true},
                    {\"title\": \"Approval\", \"value\": \"$APPROVAL_METHOD\", \"short\": true}
                  ]
                }]
              }" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"
          fi

      # =================================================================
      # Deploy Infrastructure with Terraform
      # =================================================================
      - name: Enhanced Infrastructure Apply
        working-directory: terraform
        run: |
          echo "=== Applying Infrastructure Changes ==="
          
          # =============================================================
          # Recreate Environment Configuration
          # =============================================================
          # We need to recreate the configuration since this is a new job
          mkdir -p environments/$ENVIRONMENT
          
          # Environment-specific ALB domain mapping
          case "$ENVIRONMENT" in
            "dev")
              ALB_DOMAIN="cineverse-service-alb-staging-276074081.eu-west-1.elb.amazonaws.com"
              ;;
            "staging")
              ALB_DOMAIN="cineverse-service-alb-staging-276074081.eu-west-1.elb.amazonaws.com"
              ;;
            "prod")
              ALB_DOMAIN="cineverse-prod-service-alb-964667856.eu-west-1.elb.amazonaws.com"
              ;;
          esac
          
          # =============================================================
          # Create Backend Configuration
          # =============================================================
          cat > environments/$ENVIRONMENT/backend.hcl << EOF
          bucket         = "cineverse-terraform-state-$ENVIRONMENT"
          key            = "frontend/$ENVIRONMENT/terraform.tfstate"
          region         = "${{ secrets.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "cineverse-terraform-locks"
          EOF
          
          # =============================================================
          # Create Terraform Variables (Minimal for Deployment)
          # =============================================================
          cat > environments/$ENVIRONMENT/terraform.tfvars << EOF
          environment      = "$ENVIRONMENT"
          project_name     = "cineverse"
          aws_region       = "${{ secrets.AWS_REGION }}"
          alb_domain_name  = "$ALB_DOMAIN"
          api_endpoint     = "http://$ALB_DOMAIN"
          tags = {
            Environment = "$ENVIRONMENT"
            Project     = "CineVerse"
            DeployedBy  = "${{ github.actor }}"
            DeployMethod = "${{ needs.setup.outputs.is_manual_dispatch == 'true' && 'Manual Dispatch' || 'Automated' }}"
            CommitSHA   = "${{ github.sha }}"
          }
          EOF
          
          # =============================================================
          # Set Sensitive Environment Variables
          # =============================================================
          export TF_VAR_slack_webhook_url="${{ secrets.SLACK_WEBHOOK_URL }}"
          export TF_VAR_notification_emails='["${{ secrets.NOTIFICATION_EMAIL }}"]'
          
          # =============================================================
          # Initialize Terraform
          # =============================================================
          terraform init -backend-config="environments/$ENVIRONMENT/backend.hcl"
          
          # =============================================================
          # Production Safety Measures
          # =============================================================
          if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
            echo "PRODUCTION DEPLOYMENT - Enhanced safety measures enabled"
            
            # Attempt to create backup before deployment (if rollback function exists)
            aws lambda invoke \
              --function-name "cineverse-$ENVIRONMENT-rollback-handler" \
              --payload '{"action": "backup"}' \
              /tmp/backup-response.json || echo "Backup creation skipped (function may not exist yet)"
          fi
          
          # =============================================================
          # Apply Infrastructure Changes
          # =============================================================
          terraform apply -auto-approve -var-file="environments/$ENVIRONMENT/terraform.tfvars"
          
          echo "Infrastructure deployment completed successfully"

      # =================================================================
      # Extract Infrastructure Outputs
      # =================================================================
      - name: Get Enhanced Infrastructure Outputs
        id: outputs
        working-directory: terraform
        run: |
          echo "=== Extracting Infrastructure Outputs ==="
          
          # Wait for AWS resources to stabilize
          sleep 10
          
          # =============================================================
          # Extract Standard Outputs
          # =============================================================
          S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
          CF_ID=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "")
          CF_DOMAIN=$(terraform output -raw cloudfront_domain_name 2>/dev/null || echo "")
          WEBSITE_URL=$(terraform output -raw website_url 2>/dev/null || echo "")
          
          # =============================================================
          # Extract Production-Specific Outputs
          # =============================================================
          if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
            RUM_ID=$(terraform output -raw rum_app_monitor_id 2>/dev/null || echo "")
            ROLLBACK_LAMBDA=$(terraform output -raw rollback_lambda_arn 2>/dev/null || echo "")
            echo "rum_app_monitor_id=$RUM_ID" >> $GITHUB_OUTPUT
            echo "rollback_lambda_arn=$ROLLBACK_LAMBDA" >> $GITHUB_OUTPUT
          fi
          
          # =============================================================
          # Set Outputs for Subsequent Steps
          # =============================================================
          echo "s3_bucket=$S3_BUCKET" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$CF_ID" >> $GITHUB_OUTPUT
          echo "cloudfront_domain=$CF_DOMAIN" >> $GITHUB_OUTPUT
          echo "website_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          
          echo "Infrastructure outputs extracted successfully"

      # =================================================================
      # Download Application Build Artifacts
      # =================================================================
      - name: Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ env.ENVIRONMENT }}
          path: build

      # =================================================================
      # Deploy Application to S3
      # =================================================================
      - name: Enhanced S3 Deployment
        run: |
          S3_BUCKET="${{ steps.outputs.outputs.s3_bucket }}"
          
          echo "Deploying to S3 bucket: $S3_BUCKET"
          
          # =============================================================
          # Verify Build Contents
          # =============================================================
          echo "Build contents:"
          ls -la build/
          
          # =============================================================
          # Determine Deployment Path
          # =============================================================
          # Handle different Angular build outputs (SSR vs standard)
          if [ -d "build/browser" ]; then
            echo "Angular SSR detected - deploying from browser/ directory"
            DEPLOY_PATH="build/browser"
          elif [ -f "build/index.html" ]; then
            echo "Standard Angular build detected"
            DEPLOY_PATH="build"
          else
            echo "ERROR: Neither build/browser nor build/index.html found!"
            exit 1
          fi
          
          # =============================================================
          # Create Deployment Metadata (Production Only)
          # =============================================================
          if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
            cat > "$DEPLOY_PATH/deployment-info.json" << EOF
          {
            "version": "${{ github.sha }}",
            "environment": "$ENVIRONMENT",
            "deployedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployedBy": "${{ github.actor }}",
            "branch": "${{ github.ref_name }}",
            "buildNumber": "${{ github.run_number }}",
            "deploymentMethod": "${{ needs.setup.outputs.is_manual_dispatch == 'true' && 'Manual Dispatch' || 'Automated' }}",
            "manualApproval": "${{ needs.setup.outputs.manual_approval_received }}",
            "approvalMethod": "${{ needs.approval_validation.outputs.approval_method }}"
          }
          EOF
          fi
          
          # =============================================================
          # Deploy with Optimized Cache Headers
          # =============================================================
          echo "Syncing files to S3..."
          
          # Deploy static assets with long cache (1 year)
          # These files have hashed names and can be cached indefinitely
          aws s3 sync "$DEPLOY_PATH/" s3://$S3_BUCKET/ --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.html" --exclude "*.js" --exclude "*.css" \
            --exclude "deployment-info.json"
          
          # Deploy dynamic content with short cache
          # HTML, JS, CSS files need to be checked for updates
          aws s3 sync "$DEPLOY_PATH/" s3://$S3_BUCKET/ --delete \
            --cache-control "public, max-age=0, must-revalidate" \
            --include "*.html" --include "*.js" --include "*.css" \
            --include "deployment-info.json"
          
          echo "S3 deployment completed successfully"

      # =================================================================
      # Invalidate CloudFront Cache
      # =================================================================
      - name: Enhanced CloudFront Cache Invalidation
        if: success()
        run: |
          CLOUDFRONT_ID="${{ steps.outputs.outputs.cloudfront_id }}"
          
          if [[ -z "$CLOUDFRONT_ID" ]]; then
            echo "CloudFront ID not available. Skipping invalidation."
            exit 0
          fi

          echo "Invalidating CloudFront distribution: $CLOUDFRONT_ID"

          # =============================================================
          # Create Cache Invalidation
          # =============================================================
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$CLOUDFRONT_ID" \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)

          echo "Cache invalidation created: $INVALIDATION_ID"
          
          # =============================================================
          # Wait for Invalidation (Production Only)
          # =============================================================
          # For production, wait for invalidation to complete to ensure users see updates
          if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
            echo "Waiting for cache invalidation to complete..."
            aws cloudfront wait invalidation-completed \
              --distribution-id "$CLOUDFRONT_ID" \
              --id "$INVALIDATION_ID" \
              --cli-read-timeout 300 || echo "Invalidation wait timed out"
          fi

      # =================================================================
      # Verify Deployment
      # =================================================================
      - name: Enhanced Deployment Verification
        run: |
          echo "Verifying deployment..."
          
          DOMAIN="${{ steps.outputs.outputs.cloudfront_domain }}"
          WEBSITE_URL="https://$DOMAIN"
          
          # =============================================================
          # Wait for CDN Propagation
          # =============================================================
          sleep 30
          
          # =============================================================
          # Basic Health Check
          # =============================================================
          RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" $WEBSITE_URL)
          
          if [[ "$RESPONSE_CODE" == "200" ]]; then
            echo "Application is responding correctly (HTTP $RESPONSE_CODE)"
          else
            echo "Application returned HTTP $RESPONSE_CODE (may need propagation time)"
          fi
          
          # =============================================================
          # Production-Specific Verification
          # =============================================================
          if [[ "${{ needs.setup.outputs.is_production }}" == "true" ]]; then
            echo "Running production-specific health checks..."
            
            # Check deployment metadata endpoint
            DEPLOYMENT_INFO=$(curl -s "$WEBSITE_URL/deployment-info.json" || echo "")
            if [[ -n "$DEPLOYMENT_INFO" ]]; then
              echo "Deployment info: $DEPLOYMENT_INFO"
            fi
            
            # Verify security headers
            SECURITY_HEADERS=$(curl -s -I $WEBSITE_URL | grep -E "(X-Content-Type-Options|X-Frame-Options)" || echo "")
            if [[ -n "$SECURITY_HEADERS" ]]; then
              echo "Security headers verified"
            fi
          fi

      # =================================================================
      # Send Success Notification
      # =================================================================
      - name: Send Success Notification
        if: success()
        run: |
          WEBSITE_URL="${{ steps.outputs.outputs.website_url }}"
          
          # Determine deployment method for notification
          if [[ "${{ needs.setup.outputs.is_manual_dispatch }}" == "true" ]]; then
            DEPLOY_METHOD="Manual Dispatch"
            APPROVAL_INFO="Approved via workflow input"
          else
            DEPLOY_METHOD="Automated Push"
            APPROVAL_INFO="${{ needs.approval_validation.outputs.approval_method }}"
          fi
          
          # =============================================================
          # Send Slack Success Notification
          # =============================================================
          if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"Deployment to $ENVIRONMENT completed successfully!\",
                \"attachments\": [{
                  \"color\": \"good\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"$ENVIRONMENT\", \"short\": true},
                    {\"title\": \"URL\", \"value\": \"$WEBSITE_URL\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"${{ github.sha }}\", \"short\": true},
                    {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Method\", \"value\": \"$DEPLOY_METHOD\", \"short\": true},
                    {\"title\": \"Approval\", \"value\": \"$APPROVAL_INFO\", \"short\": true}
                  ]
                }]
              }" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"
          fi
          
          echo "Deployment completed successfully!"

      # =================================================================
      # Send Failure Notification
      # =================================================================
      - name: Send Failure Notification
        if: failure()
        run: |
          # Determine deployment method for notification
          if [[ "${{ needs.setup.outputs.is_manual_dispatch }}" == "true" ]]; then
            DEPLOY_METHOD="Manual Dispatch"
          else
            DEPLOY_METHOD="Automated Push"
          fi
          
          # =============================================================
          # Send Slack Failure Notification
          # =============================================================
          if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"Deployment to $ENVIRONMENT failed!\",
                \"attachments\": [{
                  \"color\": \"danger\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"$ENVIRONMENT\", \"short\": true},
                    {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                    {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Method\", \"value\": \"$DEPLOY_METHOD\", \"short\": true},
                    {\"title\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": true}
                  ]
                }]
              }" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"
          fi

      # =================================================================
      # Generate Deployment Summary Report
      # =================================================================
      - name: Enhanced Deployment Summary
        if: always()
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          # Deployment Summary
          
          **Environment:** $ENVIRONMENT  
          **Status:** ${{ job.status }}  
          **Deployment Method:** ${{ needs.setup.outputs.is_manual_dispatch == 'true' && 'Manual Dispatch' || 'Automated Push' }}  
          **Application URL:** ${{ steps.outputs.outputs.website_url }}  
          **S3 Bucket:** ${{ steps.outputs.outputs.s3_bucket }}  
          **CloudFront ID:** ${{ steps.outputs.outputs.cloudfront_id }}  
          **Branch:** ${{ github.ref_name }}  
          **Commit:** ${{ github.sha }}  
          **Deployed by:** ${{ github.actor }}
          
          ## Approval Chain
          **Universal Approval:** ${{ needs.approval_validation.outputs.approval_status }}  
          **Approval Method:** ${{ needs.approval_validation.outputs.approval_method }}  
          **Manual Approval:** ${{ needs.setup.outputs.manual_approval_received }}  
          **Environment Approval:** ${{ needs.environment_approval.result || 'Not Required' }}  
          **Is Production:** ${{ needs.setup.outputs.is_production }}
          
          ## Infrastructure Features
          - CloudFront CDN with HTTP-compatible caching
          - ${{ needs.setup.outputs.environment != 'dev' && 'WAF protection enabled' || 'WAF protection disabled' }}
          - ${{ needs.setup.outputs.is_production == 'true' && 'Real User Monitoring enabled' || 'Real User Monitoring disabled' }}
          - ${{ needs.setup.outputs.is_production == 'true' && 'Cost monitoring enabled' || 'Cost monitoring disabled' }}
          - ${{ needs.setup.outputs.environment != 'dev' && 'Access logging enabled' || 'Access logging disabled' }}
          - ${{ needs.setup.outputs.is_production == 'true' && 'Automated rollback enabled' || 'Automated rollback disabled' }}
          
          ## Deployment Options Used
          - **Force Rebuild:** ${{ github.event.inputs.force_rebuild || 'false' }}
          - **Skip Tests:** ${{ github.event.inputs.skip_tests || 'false' }}
          - **Manual Trigger:** ${{ needs.setup.outputs.is_manual_dispatch }}
          
          ## Quick Links
          - [Application](${{ steps.outputs.outputs.website_url }})
          - [CloudWatch Dashboard](https://eu-west-1.console.aws.amazon.com/cloudwatch/home?region=eu-west-1#dashboards:)
          - [Cost Dashboard](https://console.aws.amazon.com/billing/home#/bills)
          - [Re-run Workflow](${{ github.server_url }}/${{ github.repository }}/actions/workflows/frontend-ci-cd.yml)
          EOF